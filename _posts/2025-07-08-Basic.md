베이직 프로그래밍 질문

기술 면접에서 나온 기본적인 면접 질문을 기반으로 작성합니다.

# 1.클래스와 객체
클래스는 객체를 만들어내기 위한 **설계도**혹은 **틀** 이라고 할 수 있고, 객체를 생성하는데 사용합니다.
객체는 설계도(클래스)를 기반으로 생성되며, 자신의 고유 이름과 상태, 행동을 갖습니다.
여기서 상태로는 필드, 행동은 메서드라고 표현합니다.
객체에 메모리가 할당되어 실제로 활용되는 실체는 '인스턴스'라고 부릅니다.

# 2. MVC 패턴에 대해 설명해주세요
MVC 패턴은 Model, View, Controller로 어플리케이션을 분리해서 관심사를 분리하는 패턴입니다.
**Model**은 데이터와 비즈니스 로직을 담당하고, **View**는 사용자에게 보여지는 화면을 처리하며
**Controller**는 사용자 요청을 받아서 적절한 **Model**을 호출하고, 결과를 View로 전달하는 역할을 합니다.

예를 들자면 CreateUser 기능에서 Controller가 요청을 받으면, UserService(Model)에서 비즈니스 로직을 처리하고,
그 결과를 JSON이나 HTML(view)로 응답하는 방식입니다.

<span style="background-color:#DCFFE4"> 
Q. Spring에서 MVC는 어떻게 구현하나요? </span>
A. Spring MVC에서 DispatcherServlet이 Front Controller 역할을 하고, 
@Controller, @Service, @Repository 어노테이션으로 각 계층을 구분합니다.


<span style="background-color:#DCFFE4"> Q. MVC의 단점은?</span>
A. Controller가 복잡해질수 있고, Model View사이의 의존성이 생길 수 있습니다.
이를 해결하기 위해 MVP, MVVM같은 패턴도 사용할 수 있습니다.

# 3. JPA에 대해 설명해주세요
JPA는 자바 진영의 ORM 표준 인터페이스로 객체와 관계형 데이터베이스 간의 패러다임 불일치 문제를 해결해주는 기술 입니다.

개발자가 SQL을 직접 작성하지 않아도 JPA가 객체 매핑과 SQL 생성을 자동화해주고,
Spring Data JPA와 결합하면 메서드 이름만으로도 쿼리가 자동 생성 됩니다.

실제로 프로젝트를 진행하면서 CRUD 작업이 간소화되고 개발 생산성이 크게 향상됐지만,
복잡한 쿼리나 성능 최적화가 필요한 부분은 **네이티브 쿼리**나 **Query DSL**을 함께 사용하는 것이 효과적입니다.

<span style="background-color:#DCFFE4"> Q. JPA의 N+1 의 문제는 무엇인가요?</span>
A. 연관된 엔티티를 조회할 때 추가 쿼리가 N번 실행되는 문제로,
Fetch Join 이나 @EntityGraph로 해결이 가능합니다.

<span style="background-color:#DCFFE4"> Q. Jpa와 Mybatis의 차이는?</span>
A. JPA는 객체 중심의 ORM이고 Mybatis는 SQL 중심의 매퍼입니다
JPA는 생산성이 높지만 MyBatis는 복잡한 쿼리 제어에 유용합니다.

# 4. AOP란?
AOP는 관점 지향 프로그래밍으로 핵심 비즈니스 로직과 부가 기능을 분리해서 코드 중복을 제거하는 기술입니다.
로깅, 트랜잭션 관리, 보안, 성능 모니터링 등에 활용을 합니다.

여기서 @Transaction 어노테이션도 AOP의 대표적인 예시로 트랜잭션 관리 코드를 비즈니스 로직에서 분리해줍니다.
이런 기술로 Service 클래스는 핵심 로직에만 집중할 수 있고, 부가 기능들은 재사용 가능한 모듈로 관리할 수 있어 코드 품질이 향상 됩니다.

# 5. JWT && Srping security 를 어떻게 사용했는지? 어떤것인지?

JWT란 Json Web Token으로 Json 포맷을 이용해 사용자에 대한 속성을 claim 기반의 웹토큰, 구조는 헤더, 페이로드, 시그니처로 구성되어 있습니다.

Spring security란 Spring 기반의 애플리케이션의 보안(인증, 인가 및 권한 등)을 담당하는 프레임워크로, Filter chain 기반으로 보안기능을 제공합니다.

실제 구현에서는 JwtAuthenticationFilter를 커스텀으로 만들어서 SecurityFilterChain에 추가했습니다.
이 필터에서 Authorization 헤더의 Bearer 토큰을 추출하고 검증한 후, 유효하면 SecurityContext에 인증 정보를 설정하는 방식으로 구현했습니다.

Autho0 라이브러리로 토큰 생성/검증을 처리하고, Redis를 활용해 Refresh Token과 로그아웃 된 토큰 관리도 함께 구현했습니다.

## Session VS JWT 장단점은?
Session은 서버에서 즉시 무효화가 가능하지만 서버 메모리를 사용하고, JWT는 Steteless해서 확장성이 좋지만 토큰이 크기가 작고 즉시 무효화가 어렵습니다.

## JWT의 보안취약점은?
토큰 탈취 시 만료까지 무효화가 어렵고, Payload가 Base64로만 인코딩 되어 정보 노출 위험성이 있습니다.
이를 위해 짧은 만료 시간과 HTTPS 사용, 민감정보 제외가 중요합니다

# 자바에서 의존성 주입하는 방법은?
자바의 의존성 주입 방법은 생성자 주입, 필드 주입, Setter 주입, 메소드 주입 4가지 방법이 있습니다.
생성자 주입이 가장 권장되는 방식으로 final 키워드로 불변성을 보장하고 필수 의존성을 명시할 수 있습니다.
@RequireArgsConstructor 어노테이션과 함께 사용해 코드를 간소화합니다.

필드 주입은 코드가 간단하지만 테스트하기 어렵고 불변성을 보장할 수 없어서 권장하지 않습니다.
Setter 주입은 선택적 의존성이 있을 때 사용하고, 대부분 경우 생성자 주입으로 안전하고 명확한 의존성 관리를 하는 것이 좋습니다.

# 동기와 비동기의 차이를 설명해주세요
동기 처리는 작업을 순차적으로 실행하여 이전 작업이 종료될 때까지 다음 작업이 대기하는 방식이고,
비동기 처리는 작업을 병렬로 실행해서 이전 작업의 완료를 기다리지 않고 다음 작업을 진행하는 방식입니다.

동기 처리의 장점은 코드 흐름이 명확하고 디버깅이 쉬우며 단점으론 대기 시간으로 인한 성능 저하입니다.
비동기 처리는 작업 시간 단축과 자원 효율성이고, 단점은 복잡한 설계와 디버깅의 어려움입니다.

저는 실제 프로젝트에서 300명 국회의원의 법안 정보, 국회의원 정보 등을 API에서 동기화하는 기능을 구현했었습니다.
처음에 동기화 작업으로 한 명씩 순차적으로 처리했는데, 각 API 호출이 평균 3초 이상씩 걸려 전체 작업이 10분 이상 소요되는 상황을 겪고

이를 @Async 와 CompletableFufure를 사용하여 비동기로 개선했습니다.
20개 스레드로 병렬처리해서 작업을 1.5분 단축시켜 대략 10배 이상의 성능 향상을 달성했었습니다.

