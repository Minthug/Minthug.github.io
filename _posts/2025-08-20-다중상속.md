# 자바에서 다중 상속이 불가능한 이유는?

**Diamond Problem (다이아몬드 문제)**를 가족 관계로 비유해보겠습니다:
```
할아버지 (A)
       /     \
   아버지(B)  어머니(C)
       \     /
        나 (D)
```


할아버지가 돈을 주는 방법을 가르쳐줌
아버지는 할아버지 방식을 현금으로 바꿔서 가르침
어머니는 할아버지 방식을 카드로 바꿔서 가르침
문제: 내가 돈을 줄 때 아버지 방식? 어머니 방식? 어떤 걸 따라야 할지 모호함!

이것이 바로 다중 상속의 문제입니다.

```java
class Parent {
    void giveMoney() { System.out.println("현금으로"); }
}

class Father extends Parent {
    void giveMoney() { System.out.println("아버지: 현금으로"); }
}

class Mother extends Parent {
    void giveMoney() { System.out.println("어머니: 카드로"); }
}

// 이런 게 가능하다면...
class Me extends Father, Mother {  // 실제로는 불가능!
    // giveMoney() 호출 시 어떤 버전을 사용해야 할까?
}
```

1. 자바의 해결책: 인터페이스 다중 구현
```java
interface Movable {
    void move();  // 추상 메서드만 있으니 충돌 없음
}

interface Stoppable {
    void stop();
}

class HybridCar implements Movable, Stoppable {
    // 구현 클래스에서 직접 구현하므로 모호함 없음
    public void move() {
        System.out.println("하이브리드로 달린다");
    }
    
    public void stop() {
        System.out.println("브레이크로 멈춘다");
    }
}
```
2. 컴포지션(Composition) 사용
상속 대신 **"가지고 있기"**로 해결:
```java
class Car {
    void move() { System.out.println("달린다"); }
}

class Brake {
    void stop() { System.out.println("멈춘다"); }
}

class HybridCar {
    private Car car = new Car();      // 상속 대신 포함
    private Brake brake = new Brake();
    
    public void move() {
        car.move();  // 명확하게 Car의 move 호출
    }
    
    public void stop() {
        brake.stop(); // 명확하게 Brake의 stop 호출
    }
}
```